<template>
  <BaseModal
    :open="isUpdateOpen"
    title="Attention"
    confirm-text="Update POG files"
    cancel-text="Abort"
    @close="isUpdateOpen = false"
    @confirm="updatePOG"
  >
    <p>
      Updating the POG files will overwrite all files on your keyboard generated by POG (e.g. kb.py,
      code.py, customkeys.py, etc.)
    </p>
    <p class="pt-2">Be sure to backup your code if you still need any of it.</p>
  </BaseModal>

  <BaseModal
    :open="isRestoreOpen"
    title="Restore Configuration"
    cancel-text="Cancel"
    secondary-text="Keep ID"
    confirm-text="Generate New ID"
    @close="isRestoreOpen = false"
    @secondary="restoreConfig(false)"
    @confirm="restoreConfig(true)"
  >
    <p>
      Do you want to generate new ID for the restored configuration? This is only recommended if you
      are restoring a configuration from another keyboard.
    </p>
  </BaseModal>

  <div class="mt-4 p-4 text-left">
    <p>
      <a href="https://kmkfw.io/" target="_blank" class="link">KMK</a> is a capable firmware for
      keyboards using the Rp2040.
    </p>
    <p>
      Before you proceed make sure you installed
      <a class="link" href="https://circuitpython.org/downloads" target="_blank">CircuitPython</a>
      on your controller
    </p>
    <p>
      Info: This does not work when the controller is only connected via the serial port (and not as
      mounted usb drive)
    </p>
    <br />
    <p v-if="!keyboardStore.firmwareInstalled">
      By clicking the button below, you can install KMK automatically to the following drive:
      <span class="font-mono">{{ keyboardStore.path }}</span>
    </p>
    <div class="holder">
      <div class="flex justify-center">
        <div v-if="keyboardStore.firmwareInstalled" class="stats mt-8 shadow-xl">
          <div class="stat text-left">
            <div class="stat-figure text-primary">
              <i class="mdi mdi-check text-3xl"></i>
            </div>
            <div class="stat-title">Firmware Installed</div>
            <div class="stat-value text-primary">KMK</div>
            <!--        <div class="stat-desc">modified on</div>-->
          </div>
        </div>
      </div>
      <div
        v-if="['', 'done'].includes(kmkInstallState)"
        class="mt-8 flex flex-col items-center justify-center"
      >
        <div
          class="mt-8 grid justify-center gap-4"
          :class="{
            'grid-cols-1': !keyboardStore.firmwareInstalled,
            'grid-cols-2': keyboardStore.firmwareInstalled
          }"
        >
          <button class="btn btn-primary" @click="updateKMK">
            {{ keyboardStore.firmwareInstalled ? 'update' : 'install' }} KMK
          </button>
          <button v-if="!initialSetup" class="btn btn-primary" @click="isUpdateOpen = true">
            update Firmware
          </button>
          <button v-if="!initialSetup" class="btn btn-primary" @click="backupConfiguration">
            Backup Config
          </button>
          <button
            v-if="!initialSetup || keyboardStore.firmwareInstalled"
            class="btn btn-primary"
            @click="restoreConfiguration"
          >
            Restore Config
          </button>
        </div>
        <input
          ref="fileInput"
          type="file"
          accept=".json"
          style="display: none"
          @change="handleFileUpload"
        />
      </div>
      <div v-if="initialSetup" class="mt-8 flex justify-center">
        <button
          v-if="keyboardStore.firmwareInstalled"
          class="btn btn-primary mt-4 block"
          @click="$emit('next')"
        >
          Next
        </button>
      </div>

      <div
        v-if="['downloading', 'copying', 'unpacking'].includes(kmkInstallState)"
        class="mt-4 flex flex-col items-center justify-center"
      >
        <p class="m-4 mt-8">{{ kmkInstallState || '' }}</p>
        <progress class="progress progress-primary w-56" :value="progress" max="100"></progress>
        <span v-if="progress !== 0"> {{ isNaN(progress) ? 'Done' : progress }}% </span>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref } from 'vue'
import BaseModal from './BaseModal.vue'
import { keyboardStore, addToHistory } from '../store'
import dayjs from 'dayjs'
import { ulid } from 'ulid'
import { saveConfigurationWithLoading } from '../helpers/saveConfigurationWrapper'

const progress = ref(0)
const kmkInstallState = ref('')
const isUpdateOpen = ref(false)
const isRestoreOpen = ref(false)
const fileInput = ref<HTMLInputElement>()
const pendingConfigData = ref<any>(null)

const props = defineProps<{ initialSetup: boolean }>()
const emit = defineEmits(['next', 'done'])
const startTime = ref(dayjs())
const endTime = ref(dayjs())

const updateKMK = async () => {
  await window.api.updateFirmware()
  kmkInstallState.value = 'downloading'
  startTime.value = dayjs()
}

const updatePOG = async () => {
  await saveConfigurationWithLoading(
    JSON.stringify({ pogConfig: keyboardStore.serialize(), writeFirmware: true })
  )
  isUpdateOpen.value = false
}

const backupConfiguration = async () => {
  try {
    const configData = keyboardStore.serialize()
    const jsonString = JSON.stringify(configData, null, 2)
    const blob = new Blob([jsonString], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = 'pog_backup.json'
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
  } catch (error) {
    console.error('Error downloading configuration:', error)
  }
}

const restoreConfiguration = () => {
  fileInput.value?.click()
}

const handleFileUpload = async (event: Event) => {
  const target = event.target as HTMLInputElement
  const file = target.files?.[0]
  if (!file) return
  try {
    const configData = JSON.parse(await file.text())
    pendingConfigData.value = configData
    isRestoreOpen.value = true
  } catch (error) {
    console.error('Error reading or parsing configuration file:', error)
  }
  target.value = ''
}

const restoreConfig = async (generateNewIds: boolean) => {
  if (!pendingConfigData.value) return

  const configData = generateNewIds ? { ...pendingConfigData.value } : pendingConfigData.value
  if (generateNewIds) {
    configData.id = ulid()
  }

  try {
    isRestoreOpen.value = false

    await saveConfigurationWithLoading(
      JSON.stringify({ pogConfig: configData, serial: false, writeFirmware: true })
    )
    if (keyboardStore.path) {
      const keyboardData = await window.api.selectKeyboard({ path: keyboardStore.path })
      if (keyboardData && !keyboardData.error) {
        keyboardStore.import(keyboardData)
      }
    }
    if (keyboardStore.keymap.length === 0) keyboardStore.keymap = [[]]
    keyboardStore.coordMapSetup = false

    if (props.initialSetup) {
      addToHistory(keyboardStore)
    }
    emit('done')
  } catch (e) {
    console.error('restore failed', e)
  }
}

window.api.onUpdateFirmwareInstallProgress(
  (_event: Event, value: { state: string; progress: number }) => {
    console.log('kmk progress', value)
    // don't go back from done
    if (kmkInstallState.value !== 'done') {
      kmkInstallState.value = value.state
      console.log('progress', value.progress)
      progress.value = Math.round(value.progress)
      if (value.state === 'done') {
        keyboardStore.firmwareInstalled = true
        endTime.value = dayjs()
        console.log(startTime.value, endTime.value)
      }
    }
  }
)
</script>
